"use strict";const A="known-flag",O="unknown-flag",B="argument",{stringify:p}=JSON,W=/\B([A-Z])/g,C=e=>e.replace(W,"-$1").toLowerCase(),{hasOwnProperty:D}=Object.prototype,w=(e,o)=>D.call(e,o),L=e=>Array.isArray(e),$=e=>typeof e=="function"?[e,!1]:L(e)?[e[0],!0]:$(e.type),b=(e,o)=>e===Boolean?o!=="false":o,v=(e,o)=>typeof o=="boolean"?o:e===Number&&o===""?Number.NaN:e(o),U=/[\s.:=]/,_=e=>{const o=`Flag name ${p(e)}`;if(e.length===0)throw new Error(`${o} cannot be empty`);if(e.length===1)throw new Error(`${o} must be longer than a character`);const s=e.match(U);if(s)throw new Error(`${o} cannot contain ${p(s?.[0])}`)},j=e=>{const o={},s=(n,r)=>{if(w(o,n))throw new Error(`Duplicate flags named ${p(n)}`);o[n]=r};for(const n in e){if(!w(e,n))continue;_(n);const r=e[n],t=[[],...$(r),r];s(n,t);const i=C(n);if(n!==i&&s(i,t),"alias"in r&&typeof r.alias=="string"){const{alias:c}=r,l=`Flag alias ${p(c)} for flag ${p(n)}`;if(c.length===0)throw new Error(`${l} cannot be empty`);if(c.length>1)throw new Error(`${l} must be a single character`);s(c,t)}}return o},x=(e,o)=>{const s={};for(const n in e){if(!w(e,n))continue;const[r,,t,i]=o[n];if(r.length===0&&"default"in i){let{default:c}=i;typeof c=="function"&&(c=c()),s[n]=c}else s[n]=t?r:r.pop()}return s},y="--",G=/[.:=]/,J=/^-{1,2}\w/,E=e=>{if(!J.test(e))return;const o=!e.startsWith(y);let s=e.slice(o?1:2),n;const r=s.match(G);if(r){const{index:t}=r;n=s.slice(t+1),s=s.slice(0,t)}return[s,n,o]},F=(e,{onFlag:o,onArgument:s})=>{let n;const r=(t,i)=>{if(typeof n!="function")return!0;n(t,i),n=void 0};for(let t=0;t<e.length;t+=1){const i=e[t];if(i===y){r();const l=e.slice(t+1);s?.(l,[t],!0);break}const c=E(i);if(c){if(r(),!o)continue;const[l,f,g]=c;if(g)for(let a=0;a<l.length;a+=1){r();const u=a===l.length-1;n=o(l[a],u?f:void 0,[t,a+1,u])}else n=o(l,f,[t])}else r(i,[t])&&s?.([i],[t])}r()},N=(e,o)=>{for(const[s,n,r]of o.reverse()){if(n){const t=e[s];let i=t.slice(0,n);if(r||(i+=t.slice(n+1)),i!=="-"){e[s]=i;continue}}e.splice(s,1)}},K=(e,o=process.argv.slice(2),{ignore:s}={})=>{const n=[],r=j(e),t={},i=[];return i[y]=[],F(o,{onFlag(c,l,f){const g=w(r,c);if(!s?.(g?A:O,c,l)){if(g){const[a,u]=r[c],m=b(u,l),h=(k,d)=>{n.push(f),d&&n.push(d),a.push(v(u,k||""))};return m===void 0?h:h(m)}w(t,c)||(t[c]=[]),t[c].push(l===void 0?!0:l),n.push(f)}},onArgument(c,l,f){s?.(B,o[l[0]])||(i.push(...c),f?(i[y]=c,o.splice(l[0])):n.push(l))}}),N(o,n),{flags:x(e,r),unknownFlags:t,_:i}},P=(e,o,s=process.argv.slice(2))=>{const n=e.split(",").map(l=>E(l)?.[0]),[r,t]=$(o),i=[],c=[];return F(s,{onFlag(l,f,g){if(!n.includes(l)||!t&&i.length>0)return;const a=b(r,f),u=(m,h)=>{c.push(g),h&&c.push(h),i.push(v(r,m||""))};return a===void 0?u:u(a)}}),N(s,c),t?i:i[0]};exports.U=K,exports.W=P;
